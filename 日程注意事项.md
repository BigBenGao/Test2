    wmsvr重复日程字段定义：http://rd.mailtech.cn/rd/coremail/wmdoc-read.php/design/cal/data-structure.md
    相关JIRA：
            CIM-24164 iOS-日程优化[http://jira.mailtech.cn/browse/CIM-24164]
            CIM-19462 iOS-邀请邮件列表的日程邮件可添加到个人日程[http://jira.mailtech.cn/browse/CIM-19462]
            CIM-14281 iOS-创建讨论日程默认填充讨论所有成员 [http://jira.mailtech.cn/browse/CIM-14281]
            CIM-18529 iOS-【体验优化】日程列表优先使用本地缓存 [http://jira.mailtech.cn/browse/CIM-18529]
            CIM-21468 iOS-屏蔽日程邀请外部人员入口[http://jira.mailtech.cn/browse/CIM-21468]
            CIM-16937 iOS-增加日历中日程的已过期和待办状态标识[http://jira.mailtech.cn/browse/CIM-16937]
            CIM-21437 iOS-移动端日程月视图数据刷新逻辑优化[http://jira.mailtech.cn/browse/CIM-21437]
            
###1. 计算该日程是否已经过期入口
> -(BOOL)eventOutOfTime:(LKIcs *)event;

####1.1 普通日程
    计算出日程的结束时间，如果当前时间小于日程的结束时间，则当前日程未结束

####1.2 每天重复日程在当天是否已经结束（type = 0）
> -(BOOL)handleDayOrYearRepeatEvent:(LKIcs *)event type:(NSInteger)type

    提取该日程startTime的时、分、秒,拼接上当天的年、月、日作为开始时间，加上日程的时长，计算出一个新的结束时间，
    将该结束时间和当前时间比较，如果小于当前时间则未结束


####1.3 每年重复日程在当天是否已经结束（type = 5）
> -(BOOL)handleDayOrYearRepeatEvent:(LKIcs *)event type:(NSInteger)type

    提取该日程startTime的月、日、时、分、秒,拼接上当前时间的年份作为开始时间，加上日程的时长，计算出一个新的结束时间，
    将该结束时间和当前时间比较，如果小于当前时间则未结束

####1.4 每周重复日程在当天是否已经结束（type = 1）
> -(BOOL)handleWeekRepeatEvent:(LKIcs *)event

    先通过startTime + duration 计算出原始的日程的结束时间
    将日程的开始时间格式化成yyyy-MM-dd的形式
    将当前时间格式化成yyyy-MM-dd的形式
    匹配格式化后的当前时间是否在事件的开始时间和结束时间的区间段当中
    不在区间段中则将开始时间和结束时间往下添加一个礼拜
    找到对应区间段后，将当前时间和事件结束时间进行比较


####1.5 每月重复日程在当天是否已经结束（type = 2）
> -(BOOL)handleMonthRepeatEvent:(LKIcs *)event

    先通过startTime + duration 计算出原始的日程的结束时间
    将日程的开始时间格式化成dd HH:mm:ss的形式
    将当前时间格式化成dd HH:mm:ss的形式
    如果格式化后的结束时间小于当前时间则未结束
    

###2.日程缓存的控制 

    LKScheduleCacheManager 管理缓存

    LKScheduleCacheModel 缓存实际保存的Model

    LKScheduleCacheModel : {
        @objc dynamic var cacheDateKey:String?  \\ yyyy-MM-dd 的形式，用来检索该天是否存在缓存

        @objc dynamic var events = RLMArray<LKIcs>.init(objectClassName: LKIcs.className()) \\ 该天存在的日程缓存
    }
    主要函数:
    class func cachecacheEvents(eventArray:[LKIcs]?, date:NSDate) 该函数主要是做一些初始化的准备操作
    class func addOrUpdateEvent(event:LKIcs) 计算出日程应该缓存的区间段的公共入口
    class func cacheDayRepeatEvent(event:LKIcs) 每天重复日程应该缓存的区间段计算
    class func cacheWeekRepeatEvent(event:LKIcs) 每周重复日程应该缓存的区间段计算
    class func cacheYearOrMonthRepeatEvent(event:LKIcs, monthRepeat:Bool) 每月、每年重复日程应该缓存的区间段计算
    class func cacheEvents(event:LKIcs, eventStartTime:TimeInterval, endTime:TimeInterval) 缓存写入到本地

####2.1 添加缓存的步骤1
>class func cachecacheEvents(eventArray:[LKIcs]?, date:NSDate)（date：缓存的时间，eventArray：需要缓存的日程）

    先将date格式化成yyyy-MM-dd的形式，通过该key去LKScheduleCacheModel中查询是否存在缓存
    如果eventArray为空，但是本地缓存有数据，则清空本地数据
    如果eventArray不为空，对比eventArray里面的日程和本地缓存的日程数据，剔除掉本地有，服务端没有的日程，找到两者公有的日程，再次写入realm
    以上步骤执行完后，开始调用addOrUpdateEvent计算日程应该缓存的区间段
    
####2.2 添加缓存的步骤2
> class func addOrUpdateEvent(event:LKIcs)  => 计算日程应该缓存的区间段

##### 2.2.1普通日程缓存区间段计算逻辑:
    计算出日程原始的结束时间
    先计算出日程原始的结束时间点 startTime + duration => endTime
    将日程的开始时间重置为当天时间0点这种形式 yyyy-MM-dd 00:00:00 => startTime
    将该日程、startTime、endTime送到cacheEvents函数里面进行缓存日程数据即可
    

##### 2.2.2 每天重复日程缓存区间段计算逻辑:
> 相关函数: class func cacheDayRepeatEvent(event:LKIcs)

###### 2.2.2.1 until字段不为空(非永远重复)：
    将日程的开始时间格式化为当天时间0点这种形式 yyyy-MM-dd 00:00:00,生成一个临时的开始时间 => tempStartTime
    截取until字段的yyyy-MM-dd加上日程原始时间的HH:mm:ss,格式化之后加上日程的duration，计算出一个新的日程结束时间 => endTime
    将该日程、tempStartTime、endTime送到cacheEvents该函数里面进行缓存日程数据即可

###### 2.2.2.2 until字段为空(永远重复)：
    将日程的开始时间格式化为当天时间0点这种形式 yyyy-MM-dd 00:00:00,生成一个临时的开始时间 => tempStartTime
    因为永远重复,until字段为空，这里默认保存一年，即 until = 当前时间 + 1年，再格式化成"yyyy-12-31"这种形式，生成一个until时间 => untilTime
    截取untilTime字段的yyyy-MM-dd加上日程原始时间的HH:mm:ss,格式化之后加上日程的，计算出一个新的日程结束时间 => endTime
    将该日程、tempStartTime、endTime送到cacheEvents该函数里面进行缓存日程数据即可


##### 2.2.3 每周重复日程缓存区间段计算逻辑:
> 相关函数: class func cacheWeekRepeatEvent(event:LKIcs)

dayOfWeek: 0 ~ 6 (0代表星期日 ～ 6代表星期六)
###### 2.2.3.1 until字段不为空(非永远重复)：
    将until格式化成"yyyy-MM-dd 23:59:59"这种形式 => untilTime
    将日程开始时间的时间戳做为开始条件,untilTime为结束时间，每次循环递增一周，作为日程缓存最大和最小的时间范围，建立外层的for循环
    在内部执行一个 for i in 0...6 的循环，依次算出该日程在一周内每一天的开始时间 let tempStart = start + Double(i * 86400)
    计算出tempStart的dayofwek,如果该标志和原日程的dayofwek标志相同，则事件在那一天是会需要被缓存，否则继续循环计算下一天
    找到需要被缓存的时间点后，通过tempStart + event.duration = tempEnd 得到事件的结束时间
    将该日程和tempStart、tempEnd送到cacheEvents该函数里面进行缓存日程数据即可

###### 2.2.3.2 until字段为空(永远重复)：
    将当前时间加上一年，并格式化成"yyyy-12-31 23:59:59"这种形式做为缓存的截止时间 => untilTime
    将日程开始时间的时间戳为开始条件,untilTime为结束时间，每次循环递增一周，作为日程缓存最大和最小的时间范围，建立外层的for循环
    在内部执行一个 for i in 0...6 的循环，依次算出改日程在一周内每一天的开始时间 let tempStart = start + Double(i * 86400)
    计算出tempStart的dayofwek,如果该标志和原日程的dayofwek标志相同，则事件在那一天是会需要被缓存，否则继续循环计算下一天
    找到需要被缓存的时间点后，通过tempStart + event.duration = tempEnd 得到事件的结束时间
    将该日程和tempStart、tempEnd送到cacheEvents该函数里面进行缓存日程数据即可
       
##### 2.2.4 每月重复日程缓存区间段计算逻辑:
> 相关函数: class func cacheYearOrMonthRepeatEvent(event:LKIcs, monthRepeat:Bool)

###### 2.2.4.1 until字段不为空(非永远重复)：
    获取日程开始时间是几号，则该天就是每月需要重复的时间(2020-07-13 提取里面的13号，则事件每月13号会重复)
    将until格式化成"yyyy-MM-dd 23:59:59"这种形式 => untilTime
    将untilTime的时间戳做为结束的条件 => cacheEndTime 
    原始日程开始时间的时间戳为缓存计算起点 => tempStart
    以tempStart为起点、cacheEndTime为终点，做为缓存的区间段，执行循环，每次循环结束，tempStart增加一个月(这里要注意2月份的问题，比如1月31号加一个月的时间变成2月31号,这时候calendar解析返回是null的，此时直接往下叠加一个月份即可)
    通过tempStart + duration 得到日程的结束时间 => tempEventEndTime
    将该日程、tempStart、tempEventEndTime送到cacheEvents该函数里面进行缓存日程数据即可
    重复循环，直到tempStart大于cacheEndTime为止

###### 2.2.4.2 until字段为空(永远重复)：
    获取日程开始时间是几号，则该天就是每月需要重复的时间(2020-07-13 提取里面的13号，则事件每月13号会重复)
    初始化until字段, until = 当前时间 + 1年 => untilTime
    将until格式化成"yyyy-12-31 23:59:59"这种形式 => untilTime
    将untilTime的时间戳做为结束的条件 => cacheEndTime
    原始日程开始时间的时间戳为缓存计算起点 => tempStart
    以tempStart为起点、cacheEndTime为终点，做为缓存的区间段，执行循环，每次循环结束，tempStart增加一个月(这里要注意2月份的问题，比如1月31号加一个月的时间变成2月31号,这时候calendar解析返回是null的，此时直接往下叠加一个月份即可)
    通过tempStart + duration 得到日程的结束时间 => tempEventEndTime
    将该日程、tempStart、tempEventEndTime送到cacheEvents该函数里面进行缓存日程数据即可
    重复循环，直到tempStart大于cacheEndTime为止

##### 2.2.5 每年重复日程缓存区间段计算逻辑:
> 相关函数: class func cacheYearOrMonthRepeatEvent(event:LKIcs, monthRepeat:Bool)

###### 2.2.5.1 until字段不为空(非永远重复)：
    1. 将until格式化成"yyyy-MM-dd 23:59:59"这种形式 => untilTime
    2. 将第一步生成的untilTime的时间戳做为缓存结束的条件 => cacheEndTime 
    3. 原始日程开始时间的时间戳为缓存计算起点 => tempStart
    4. 以tempStart为起点、cacheEndTime为终点，做为缓存的区间段，执行循环，每次循环结束，tempStart增加一年(这里要注意2月份的问题，比如每年的2月29号重复该日程，平年的2月有28天、闰年的2月有29天，加一年之后如果该日子不存在的,这时候calendar解析返回是null的，直接往下叠加一年即可)
    5. 通过tempStart + duration 得到日程的结束时间 => tempEndTime
    6. 将该日程、tempStart、tempEndTime送到cacheEvents该函数里面进行缓存日程数据即可
    7. 继续for循环，重复4、5、6步骤，直到tempStart > cacheEndTime为止
    
###### 2.2.5.2 until字段为空(永远重复)：
    1: 初始化until字段, until = 当前时间 + 1年 => untilTime
    2: 将第一步生成的untilTime的时间戳做为缓存结束的条件 => cacheEndTime
    3. 原始日程开始时间的时间戳为缓存计算起点 => tempStart
    4: 以tempStart为起点、cacheEndTime为终点，做为缓存的区间段，执行循环，每次循环结束，tempStart增加一年(这里要注意2月份的问题，比如每年的2月29号重复该日程，平年的2月有28天、闰年的2月有29天，加一年之后如果该日子不存在的,这时候calendar解析返回是null的，直接往下叠加一年即可)
    5. 通过tempStart + duration 得到日程的结束时间 => tempEndTime
    6. 将该日程、tempStart、tempEndTime送到cacheEvents该函数里面进行缓存日程数据即可
    7. 继续for循环，重复4、5、6步骤，直到tempStart > cacheEndTime为止
    
    
####2.3 缓存到本地
> 相关函数: class func cacheEvents(event:LKIcs, eventStartTime:TimeInterval, endTime:TimeInterval)

    缓存逻辑:
    1. 以传进来的eventStartTime为开始时间、endTime为结束时间
    2. 将eventStartTime格式化成 "yyyy-MM-dd" 的形式生成 cacheKey  =>  cacheKey
    3. 通过cacheKey在LKScheduleCacheModel中找出对应的缓存Model => cacheModel
        3.1 从realm中查询缓存为空，则以cacheKey，生成cacheModel，并在model的events中加入该事件
        3.2 从realm中查询缓存非空，查看一下cacheModel的events中是否包含该日程，如果不包含则将该日程加入events，否则不做处理
    4. 计算完之后，eventStartTime往下加一天，继续缓存该日程，重复2，3，4步骤直到eventStartTime时间大于endTime为止

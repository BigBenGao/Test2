###1. 计算该日程是否已经过期入口
> -(BOOL)eventOutOfTime:(LKIcs *)event;

######1.1 普通日程
	计算出日程的结束时间，如果当前时间小于日程的结束时间，则当前日程未结束

######1.2 每天重复日程在当天是否已经结束（type = 0）
> -(BOOL)handleDayOrYearRepeatEvent:(LKIcs *)event type:(NSInteger)type

	提取该日程startTime的时、分、秒,拼接上当天的年、月、日作为开始时间，加上日程的时长，计算出一个新的结束时间，
	将该结束时间和当前时间比较，如果小于当前时间则未结束

1.3 每年重复日程在当天是否已经结束（type = 5）
-(BOOL)handleDayOrYearRepeatEvent:(LKIcs *)event type:(NSInteger)type
1.3.1 提取该日程startTime的月、日、时、分、秒,拼接上当前时间的年份作为开始时间，加上日程的时长，计算出一个新的结束时间，
将该结束时间和当前时间比较，如果小于当前时间则未结束

1.4 每周重复日程在当天是否已经结束（type = 1）
-(BOOL)handleWeekRepeatEvent:(LKIcs *)event
1.4.1  先通过startTime + duration 计算出原始的日程的结束时间
1.4.2 将日程的开始时间格式化成yyyy-MM-dd的形式
1.4.3 将当前时间格式化成yyyy-MM-dd的形式
1.4.3. 匹配格式化后的当前时间是否在事件的开始时间和结束时间的区间段当中
1.4.4. 不在区间段中则将开始时间和结束时间往下添加一个礼拜
1.4.5. 找到对应区间段后，将当前时间和事件结束时间进行比较


1.5 每月重复日程在当天是否已经结束（type = 2）
-(BOOL)handleMonthRepeatEvent:(LKIcs *)event
1.5.1  先通过startTime + duration 计算出原始的日程的结束时间
1.5.2 将日程的开始时间格式化成dd HH:mm:ss的形式
1.5.3 将当前时间格式化成dd HH:mm:ss的形式
1.5.3 如果格式化后的结束时间小于当前时间则未结束

2.日程缓存的控制 
##LKScheduleCacheManager.swift 缓存的管理, LKScheduleCacheModel 缓存实际保存的Model
\\\
    LKScheduleCacheModel : {
  
        @objc dynamic var cacheDateKey:String?  \\ yyyy-MM-dd 的形式，用来检索该天是否存在缓存

        @objc dynamic var events = RLMArray<LKIcs>.init(objectClassName: LKIcs.className()) \\ 该天存在的日程缓存
    }
\\\

2.1 添加缓存的入口（date：缓存的时间，eventArray：需要缓存的日程）
@objc public class func cachecacheEvents(eventArray:[LKIcs]?, date:NSDate)

2.1.1 先将date格式化成yyyy-MM-dd的形式，通过该key去LKScheduleCacheModel中查询是否存在缓存
    2.1.1.1 如果eventArray为空，但是本地缓存有数据，则清空本地数据
    2.1.1.2 如果eventArray不为空，对比eventArray里面的日程和本地缓存的日程数据，剔除掉本地有，服务端没有的日程，找到两者公有的日程，再次写入realm
    
2.1.2 将eventArray里面的日程写入到本地  @objc public class func addOrUpdateEvent(event:LKIcs)

普通日程:

    步骤1: 计算出日程原始的结束时间
    步骤2: 将日程的开始时间重置为当天时间0点这种形式 yyyy-MM-dd 00:00:00
    步骤3: 将该日程和新的开始时间和原始的结束时间送到cacheEvents该函数里面进行缓存日程数据即可
  
  
每天重复日程: class func cacheDayRepeatEvent(event:LKIcs)
    
    until字段不为空(非永远重复)：
        步骤1: 将日程的开始时间格式化为当天时间0点这种形式 yyyy-MM-dd 00:00:00,生成一个新的开始时间 => startTime
        步骤2: 截取until字段的yyyy-MM-dd加上日程原始时间的HH:mm:ss,格式化之后加上日程的时长，计算出一个新的日程结束时间 => endTime
        步骤3: 将该日程和startTime、endTime送到cacheEvents该函数里面进行缓存日程数据即可
    
    until字段为空(永远重复)：
        步骤1: 将日程的开始时间格式化为当天时间0点这种形式 yyyy-MM-dd 00:00:00,生成一个新的开始时间 => startTime
        步骤2: 因为永远重复,until字段为空，这里默认保存一年，即 until = 当前时间 + 1年，再格式化成"yyyy-12-31"这种形式，生成一个until时间 => untilTime
        步骤3: 截取untilTime字段的yyyy-MM-dd加上日程原始时间的HH:mm:ss,格式化之后加上日程的时长，计算出一个新的日程结束时间 => endTime
        步骤4: 将该日程和新的开始时间和新的结束时间送到cacheEvents该函数里面进行缓存日程数据即可


每周重复日程: class func cacheWeekRepeatEvent(event:LKIcs)
         
      dayOfWeek: 0 ~ 6 (0代表星期日 ～ 6代表星期六)
      
       until字段不为空(非永远重复)：
       步骤1: 将until格式化成"yyyy-MM-dd 23:59:59"这种形式 => untilTime
       步骤2: 将日程开始时间的时间戳为开始条件,untilTime为结束时间，每次循环递增一周，作为日程缓存最大和最小的事件范围，建立外层的for循环
       步骤3: 在内部执行一个 for i in 0...6 的循环，依次算出改日程在一周内每一天的开始时间
            let tempStart = start + Double(i * 86400)
       步骤4: 计算出tempStart的dayofwek,如果该标志和原日程的dayofwek标志相同，则事件在那一天是会需要被缓存，否则继续循环计算下一天
       步骤5: 找到需要被缓存的时间点后，通过tempStart + event.duration = tempEnd 得到事件的结束时间
       步骤6: 将该日程和tempStart、tempEnd送到cacheEvents该函数里面进行缓存日程数据即可
       
       until字段为空(永远重复)：
       步骤1: 将当前时间加上一年，并格式化成"yyyy-12-31 23:59:59"这种形式 => untilTime
       步骤2: 将日程开始时间的时间戳为开始条件,untilTime为结束时间，每次循环递增一周，作为日程缓存最大和最小的事件范围，建立外层的for循环
       步骤3: 在内部执行一个 for i in 0...6 的循环，依次算出改日程在一周内每一天的开始时间
            let tempStart = start + Double(i * 86400)
       步骤4: 计算出tempStart的dayofwek,如果该标志和原日程的dayofwek标志相同，则事件在那一天是会需要被缓存，否则继续循环计算下一天
       步骤5: 找到需要被缓存的时间点后，通过tempStart + event.duration = tempEnd 得到事件的结束时间
       步骤6: 将该日程和tempStart、tempEnd送到cacheEvents该函数里面进行缓存日程数据即可
       

每月重复日程:
     
     until字段不为空(非永远重复)：
     步骤1: 获取日程开始时间是几号，则该天就是每月需要重复的时间(2020-07-13 提取里面的13号，则事件每月13号会重复)
     步骤2: 将until格式化成"yyyy-MM-dd 23:59:59"这种形式 => untilTime
     步骤3: 将untilTime的时间戳做为结束的条件 => endTime 
     步骤4: 外部以日程开始时间的时间戳为缓存计算起点，endTime为终点，执行循环，每次循环结束，开始时间增加一个月(这里要注意2月份的问题，比如1月31号加一个月的时间变成2月31号,这时候calendar解析返回是null的，直接往下叠加一个月份即可)
     步骤5: 通过startTime + duration 得到日程的结束时间 => endTime
     步骤6: 将该日程和tempStart、tempEnd送到cacheEvents该函数里面进行缓存日程数据即可
     
     until字段不为空(永远重复)：
     步骤1: 获取日程开始时间是几号，则该天就是每月需要重复的时间(2020-07-13 提取里面的13号，则事件每月13号会重复)
     步骤2: 初始化Until字段, until = 当前时间 + 1年 => untilTime
     步骤3: 将until格式化成"yyyy-12-31 23:59:59"这种形式 => untilTime
     步骤3: 将untilTime的时间戳做为结束的条件 => endTime 
     步骤4: 外部以日程开始时间的时间戳为缓存计算起点，endTime为终点，执行循环，每次循环结束，开始时间增加一个月(这里要注意2月份的问题，比如1月31号加一个月的时间变成2月31号,这时候calendar解析返回是null的，直接往下叠加一个月份即可)
     步骤5: 通过startTime + duration 得到日程的结束时间 => endTime
     步骤6: 将该日程和tempStart、tempEnd送到cacheEvents该函数里面进行缓存日程数据即可
 
    
每年重复日程:
    
    until字段不为空(非永远重复事件)：
    步骤1: 将until格式化成"yyyy-MM-dd 23:59:59"这种形式 => untilTime
    步骤2: 将untilTime的时间戳做为结束的条件 => endTime 
    步骤3: 外部以日程开始时间的时间戳为缓存计算起点，endTime为终点，执行循环，每次循环结束，开始时间增加一年(这里要注意2月份的问题，比如每年的2月29号重复该日程，平年的2月有28天、闰年的2月有29天，加一年之后如果该日子不存在的,这时候calendar解析返回是null的，直接往下叠加一年即可)
    步骤4: 通过startTime + duration 得到日程的结束时间 => endTime
    步骤5: 将该日程和startTime、endTime送到cacheEvents该函数里面进行缓存日程数据即可
    步骤6: startTime加上一年做为新的startTime继续for循环，重复4、5、6步骤，直到startTime > endTime截止

    until字段为空(永远重复事件)：
    步骤1: 初始化until字段, until = 当前时间 + 1年 => untilTime
    步骤2: 将until格式化成"yyyy-12-31 23:59:59"这种形式 => untilTime
    步骤3: 将untilTime的时间戳做为结束的条件 => endTime 
    步骤4: 外部以日程开始时间的时间戳为缓存计算起点，endTime为终点，执行循环，每次循环结束，开始时间增加一年(这里要注意2月份的问题，比如每年的2月29号重复该日程，平年的2月有28天、闰年的2月有29天，加一年之后如果该日子不存在的,这时候calendar解析返回是null的，直接往下叠加一年即可)
    步骤5: 通过startTime + duration 得到日程的结束时间 => endTime
    步骤6: 将该日程和startTime、endTime送到cacheEvents该函数里面进行缓存日程数据即可
    步骤7: startTime加上一年做为新的startTime继续for循环，重复4、5、6步骤，直到startTime > endTime截止


实际做缓存的函数

1.  以日程的开始时间和结束时间作为临界点
2.  将日程开始时间格式化成 "yyyy-MM-dd" 的形式生成 cacheKey  =>  cacheKey
3.  通过cacheKey在LKScheduleCacheModel中找出对应的缓存Model => cacheModel
    3.1 从realm中查询缓存为空，则以cacheKey，生成cacheModel，并在model的events中加入该事件
    3.2 从realm中查询缓存非空，查看一下cacheModel的events中是否包含该日程，如果不包含则将该日程加入events，否则不做处理
4. 计算完之后，日程的开始时间往下加一天作为新的cacheKey，继续缓存该日程，直到时间大于结束时间为止

        class func cacheEvents(event:LKIcs, eventStartTime:TimeInterval, endTime:TimeInterval) {
        
            for start in stride(from: eventStartTime, to: endTime, by: 86400) {
        
            let cacheDate = NSDate.init(timeIntervalSince1970: start)
        
            guard let key = cacheDate.dateString(byFormat: "yyyy-MM-dd") else {
                continue
                }
        
            var model = LKScheduleCacheModel.safeObject(forPrimaryKey: key)
        
            if model == nil {
                model = LKScheduleCacheModel(cacheDateKey: key)
                model?.events = RLMArray.init(objectClassName: LKIcs.className())
                }
        
            var found = false
        
            if let tempArray = model?.events {
                for ics in tempArray {
                    if let temp = ics as? LKIcs, temp.icsUid == event.icsUid {
                        found = true
                        break
                    }
                }
            }
        
            if let cacheModel = model, !found {
                let tempEvent = LKIcs.safeObject(forPrimaryKey: event.icsUid) ?? event
                QDatabaseHP.currentThreadBlock { (realm) in
                    cacheModel.events.add(tempEvent)
                    realm?.addOrUpdate(cacheModel)
                }
            }
        }
